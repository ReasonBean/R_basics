### vector ###

## vector generation
x <- c(123) # 123
y <- c(1,4,10,20) #  1  4 10 20

## vector is generated by :
a <- 1:10 #  1  2  3  4  5  6  7  8  9 10
b <- 2:6 # 2 3 4 5 6
c <- 2:-2 #  2  1  0 -1 -2
d <- T:3 # 1 2 3, T is 1

## vector sequence
sequence1 <- seq(from = 1, to = 10)
sequebce2 <- sequence2 <- seq(from = 1, to = 10, by = 2) # Generate a sequence from 1 to 10, incrementing by 2
sequence3 <- seq(from = 1, to = 10, length.out = 5) # Generate a sequence from 1 to 10 with a length of 5

## vector replication
repeated_value <- rep(5, times = 5) # Replicate the number 5, five times
repeated_vector <- rep(c(1, 2, 3), each = 3) # Replicate each element in the vector
limited_replication <- rep(c(1:10), each=2, len=5) # Replicate a number with a length limit

## vector value modifies by using index
limited_replication[1] = 5 # 5 1 2 2 3

## append and replace
append(1:10, 100) # 1 2 3 4 5 6 7 8 9 10 100

original_vector <- c(1, 2, 4, 5) # Original vector
new_vector <- append(original_vector, 3, after = 2) # Append the number 3 after the second position, 1, 2, 3, 4, 5

original_vector <- c(1, 2, 3, 4, 5) # Original vector
replaced_vector <- replace(original_vector, list = c(2, 5), values = c(20, 50)) # Replace the second and fifth elements with 20 and 50, 1, 20, 3, 4, 50

## names()
fruits <- c(10, 15, 5, 20) # Create and name a vector
names(fruits) <- c("Apple", "Banana", "Cherry", "Date")

names(fruits)[2] <- "Blueberry" # Create and name a vector

fruits[-2] # Delete index number 2

## sort()
numeric_vector <- c(10, 2, 30, 4, 50, 6)
sorted_vector <- sort(numeric_vector) # Sort the vector in ascending order
sorted_vector_reverse <- sort(numeric_vector, decreasing = T) # Sort the vector in descending order

### matrix
## matrix setting
m1 <- matrix(data = 1:9, nrow = 3, ncol = 3) # Create a matrix with numbers from 1 to 9, ☢️matrix can save the value by column(column is the first)
m2 <- matrix(data = 1:9, nrow = 3, ncol = 3, byrow = TRUE) # Create a matrix with numbers from 1 to 9, matrix can be generated the value by row is the first
m5 <- matrix(data = 1:4, nrow = 2, dimnames = list(c("Row1", "Row2"), c("Col1", "Col2"))) # Name matrix

attributes(m5) # attributes about the matrix, this is list
rownames(m5) <- c("R1", "R2")
colnames(m5) <- c("C1", "C2")

## rbind() and cbind()
rbind(1:4, 4:1, 1:2)
cbind(1:5, 11:15)

## matrix indexing
mat<-matrix(1:12, ncol=4)
mat[2,3] # row=2, col=3
mat[-2,] # Delete row index number 2

## matrix transpose
t(mat) # transform to transpose
c(mat) # transform to vector
as.vector(mat) # transform to vector

### array
data_vector <- 1:12 # Create a three-dimensional array
dim_vector <- c(2, 3, 2)  # 2 rows, 3 columns, and 2 layers
my_3d_array <- array(data_vector, dim = dim_vector)
my_3d_array[1,1,2] # print 7

### list
my_list <- list(name = "John Doe", age = 30, married = TRUE, children_names = list("Alice", "Bob")) # Create a list containing various types of elements
# result
# my_list$children_names[[1]] [1] "Alice", my_list$children_names[[2]] [1] "Bob"

### factor
fruit_names <- c("apple", "banana", "orange", "apple", "banana") # Create a vector of categories
fruit_factors <- factor(fruit_names) # Convert the vector to a factor
print(fruit_factors) # Print the factor
length(fruit_factors) # Lengths the vector
levels(fruit_factors) # Levels the factor

### data fram
## data frame setting
my.df <- data.frame( # Create a data frame
  Name = c("Alice", "Bob", "Charlie"),
  Age = c(25, 30, 35),
  Salary = c(50000, 60000, 70000),
  row.names = c("a", "b", "c")
)

## data frame indexing
my.df[["Name"]] # my.df[[1]] = my.df$Name
my.df["a",1:2] # similar to matrix

## iris data set
iris[iris$Species=="setosa",]
mod<-iris[iris$Species=="setosa", c("Sepal.Length", "Species")] # Sepal.Length and Species with setosa

chg<-cbind(mod, number=seq(1:50)) # binding new column
transform(iris, newc=11:16) # binding new column

iris[iris[,"Petal.Length"]>3,] # find out rows of petal length > 3

## data frame drop
df <- data.frame(x = 1:5, y = 6:10)

result <- df[, "x"] # if drop = TRUE
print(result) # result is vector

result <- df[, "x", drop=F] # if drop = FALSE
print(result) # result is data frame
View(result)

### read table, write table
## read.table
# read.table("file.csv", sep = ",") # load csv
# read.table("file.tsv", sep = "\t") # load tsv

## write.table
# write.table(df, "file.csv", sep = ",",  col.names = T, row.names = T, quote = F)

### if else in R
x<-2:-2
ifelse(x>=0, x, -x)
ifelse(x>=0, log(x), NA)

### function with recursive
recursive<-function(vec){
  if(length(vec)==1){ # If only one element of the vector remains (when 20), return only by squared
    return(vec[1]^2)
  }
  return(vec[1]^2+recursive(vec[-1])) # Squared for the first element and moved the remaining elements back to a recursive function, returning the final value at the end of the operation
  # return(vec[1]^2+recursive(vec[2:length(vec)])) it is possible
}

### statistical function
sum(iris$Sepal.Length)
min(iris$Sepal.Length)
max(iris$Sepal.Length)
range(iris$Sepal.Length)
mean(iris$Sepal.Length)
median(iris$Sepal.Length)
sd(iris$Sepal.Length)
fivenum(iris$Sepal.Length) # Min, Q1, Median, Q2, MAX

num<-as.numeric(summary(iris$Sepal.Length)["Min."]) # Save the value from the summary
num

abs(iris$Sepal.Length)
sqrt(iris$Sepal.Length)
ceiling(iris$Sepal.Length)
floor(iris$Sepal.Length)
trunc(iris$Sepal.Length)
round((iris$Sepal.Length), 0)
log10(iris$Sepal.Length)
log2(iris$Sepal.Length)
exp(iris$Sepal.Length)
factorial(iris$Sepal.Length) # factorial with integer

cos(iris$Sepal.Length)
sin(iris$Sepal.Length)
tan(iris$Sepal.Length)

### apply function
## apply
apply(iris[,1:4], 1, mean) # column 1 to 4, by row, apply mean(it is fault)
apply(iris[,1:4], 2, mean) # column 1 to 4, by col, apply mean

## lapply
lapply(iris[,1:4], mean) # return to list

## sapply
sapply(iris[,1:4], mean, simplify = F) # it is same to apply(iris[,1:4], 2, mean)

## tapply
tapply(iris$Sepal.Length, iris$Species, mean) # Function is applied to each index for data

### statistical function
## normal distribution
random_numbers <- rnorm(5, mean = 0, sd = 1) # choose 5 numbers with mean=0, sd=1 normal distribution
quantile_value <- qnorm(0.975, mean = 0, sd = 1) # Calculate values corresponding to the top 2.5% in a normal distribution with a mean=0, sd=1
cumulative_prob <- pnorm(1.96, mean = 0, sd = 1) # Calculate the cumulative probability of x <= 1.96 from a normal distribution with a mean=0, sd=1
density <- dnorm(0, mean = 0, sd = 1) # Calculate the probability density of x = 0 in a normal distribution with a mean=0, sd=1, y score

## uniform distribution
runif(5, 0, 1) # choose 10 numbers with min=0, max=1 uniform distribution

## histogram
hist(runif(100))
hist(rnorm(100))

### linear regression
lm.res<-lm(iris$Petal.Width ~ iris$Petal.Length) # simple linear regression model
lm.res<-lm(Petal.Width~., data=iris) # multiple linear regression model
plot(iris$Petal.Length, iris$Petal.Width) # plot
abline(lm.res) # regression line

lm.res$coeff[1] # intercept
lm.res$coeff[2] # iris$Petal.Length

### Operators
v1<-c(7,5,9)
v2<-c(18,33,4)

## remainder
v1%%v2

## quotient
v1%/%v2

## exponent
v1^v2

## identify belonging
v1%in%v2

## matrix multiply
v1%*%v2 # 7*18+5*33+9*4

### R charts
## pie chart
counts <- c(10, 20, 30, 40)
labels <- c("Red", "Blue", "Green", "Yellow")
percent<-round(counts/sum(counts)*100)
labels<-paste(labels, percent)
labels<-paste0(labels,"%")
pie(counts, labels, main = "Pie Chart Practice")

colors<-rainbow(length(labels))
pie(counts, labels = labels, col = colors, main = "Adjusted Pie Chart", init.angle = 90, clockwise = TRUE) # Set the starting angle to 90 degrees and list the pieces counterclockwise

### scatter plot
input <- mtcars[,c("wt","mpg")] # sample data

plot(input$wt, input$mpg, main = "Basic Scatter Plot", xlab = "Weight", ylab = "Milage", xlim=c(2.5, 5), ylim=c(15,30),
     pch = 19, col = "blue") # pch is circle

abline(lm(input$mpg~input$wt)) # regression line

### box plot
# Creating a box plot of mpg according to the number of cylinders (cyl)
boxplot(mpg ~ cyl, data = mtcars,
        main = "Miles Per Gallon by Number of Cylinders",
        xlab = "Number of Cylinders",
        ylab = "Miles Per Gallon (mpg)",
        col = c("lightblue", "lightgreen", "lightcoral"))

### histogram
hist(mtcars$mpg, freq = FALSE, breaks = 12, col = "lightblue", # y axis is set density
     main = "Histogram of MPG with Density Curve",
     xlab = "Miles Per Gallon (MPG)",
     border = "lightblue")
dens <- density(mtcars$mpg)
lines(dens, type="l", col = "red", lwd = 2) # add to density curve
grid() # grid

plot(dens) # Density Plot
polygon(dens, col = "lightblue", border = "lightblue")

### complex plot
## normal legend
x <- mtcars$wt
y <- mtcars$mpg

plot(x, y, type = "o",      # point with lines
     main = "MPG vs Weight",
     xlab = "Weight (1000 lbs)",
     ylab = "Miles per Gallon",
     col = "blue",          # color
     lty = 2,               # line type
     lwd = 2,               # line width
     cex = 1.2,             # character expansion
     frame = FALSE)         # remove outer line

legend("topright",           # legend position
       legend = "MPG vs Weight", # legend text
       col = "blue",         # legend color
       lty = 2,              # legend line type
       lwd = 2,              # legend line width
       cex = 0.8)            # legend character expansion

## upgrade legend
plot(mtcars$wt, mtcars$mpg, type = "o", col = "blue", lty = 1,
     main = "MPG and Horsepower vs Weight",
     xlab = "Weight (1000 lbs)", ylab = "Value",
     ylim = c(min(mtcars$mpg, mtcars$hp), max(mtcars$mpg, mtcars$hp)))

# line graph
lines(mtcars$wt, mtcars$hp, type = "o", col = "red", lty = 2)

# legend with 2 variable
legend("topright", legend = c("MPG", "Horsepower"), 
       col = c("blue", "red"), lty = c(1, 2), cex = 0.8)

# par(mfrow=c(3,2))
# par(mfrow=c(1,1))

### Layout
# Data preparation
x <- 1:10
y1 <- x^2
y2 <- log(x)
y3 <- sqrt(x)

# Graphic layout settings
layout(matrix(c(1,1,2,3), nrow=2, byrow=TRUE))

# Draw a graph
plot(x, y1, main="Area 1: x squared") # it shows rectangular
plot(x, y2, main="Area 2: log(x)")
plot(x, y3, main="Area 3: sqrt(x)")

### Handling Text(It is very important, you have to understand these whole processes)
## String vector
str <- letters[1:5] # "a" "b" "c" "d" "e"

mean(str) # NA
nchar(str) #  1 1 1 1 1

str[3:4]<-c("Yes", "No")

nchar(str) # 1 1 3 2 1
length(str) # 5

## String connection(paste)
paste(c("a", "b", "c"), 1:5)
paste(c("a", "b", "c"), 1:5, sep="") # it is similar to paste0(c("a", "b", "c"), 1:5)

str.paste<-paste(paste(1:3, c(10,20,30), sep = " (which is "), "%)")
cat(str.paste, sep="\n") # line by line print

paste(1:3, " (which is ", c(10,20,30), " %)", sep = "") # same result, it is more intuitive

seq<-paste0(gcf.fna$NC_045512.2, collapse = "") # collapse is important to handle the sequence data
unique_bases<-unique(gcf.fna$NC_045512.2) # unique element print

## String split
library(stringr)
text <- "apple,banana,cherry"
split_text.v1 <- stringr::str_split(text, pattern = ",") # return is list
split_text.v2 <- str_split(text, pattern = ",", n=2) # only 2
split_text.v3 <- str_split(text, pattern = ",", simplify = T) # return is matrix

## String extraction
View(state.x77)
state<-head(rownames(state.x77), 5) # "Alabama"    "Alaska"     "Arizona"    "Arkansas"   "California"

substring(state, 1, 5) # it is similar to str_sub(state, 1, 5) "Alaba" "Alask" "Arizo" "Arkan" "Calif"
# substring(state, 1:5, 3:7)
substring(state, nchar(state)-2, nchar(state))

##⭐ String Replace(It is not the same integer replace)
text <- "Today is Monday"
substring(text, 10, 12)<-"Sun"

sub("a", "o", x) # Replace 'a' with 'o' for the first time
gsub("a", "o", x) # Replace 'a' with 'o' all of things

## String index return
x <- c("apple", "banana", "cherry", "date")
grep("a", x) # return to index included in 'a'
grep("a", x)

grepl("a", x) # return to logical value included in 'a'

regexpr("a", x) # The regexpr() function returns the length of the character that matches the position of the first part of the string that matches the pattern.
index.x<-gregexpr("a", x, ) # The gregexpr() is similar to regexpr(), but returns the position and length of all parts that match the pattern throughout the string.

for (ii in 1:length(index.x[[2]])){ # we cab find each 'a' position
  print(index.x[[2]][ii])
}

## String invert
original_string <- "Hello, World!"
rev(original_string) # vector invert(it is not useful when the vector has one element)

library(stringi)
reversed_string <- stri_reverse(original_string)
reversed_string # "!dlroW ,olleH", it can be useful when we control the RNA seq to DNA seq

### Packages
## Manual
vignette("ggplot2")

## heatmap and pheatmap
df<-scale(mtcars) # scaling must be conducted to make a heatmap, pheatmap plot
heatmap(df, scale = "row") # Built-in function

library(pheatmap)
pheatmap::pheatmap(df)

pheatmap::pheatmap(df, 
         # Cluster_rows and cluster_cols: Cluster rows and columns respectively, which group rows and columns with similar patterns.
         cluster_rows = T, 
         cluster_cols = T,
         main = "Heatmap of mtcars",
         color = colorRampPalette(c("navy", "white", "firebrick"))(100),
         border_color = NA)

## ⭐⭐⭐⭐⭐ dplyr
# select
dplyr::select(iris, 5, 3:4) # select 5, 3, and 4 column
dplyr::select(iris, starts_with("Petal")) # select all starts with Petal column
dplyr::select(iris, -Species) # select all columns without Species column
dplyr::select(iris, contains("length")) # select all columns with length column
dplyr::select(iris, ends_with("length")) # select all ends with length column
dplyr::select(iris, matches("^s.+")) # select columns starts with s

# filter
dplyr::filter(iris, Species=="virginica") # select Species column that has virginica
dplyr::filter(iris, Petal.Length>6) # select Petal.Length column that has more value than 6
dplyr::filter(iris, between(Petal.Length, 3, 3.5)) # select Petal.Length column that has value between 3 and 3.5

# arrange
dplyr::arrange(filter(iris, between(Petal.Length, 3, 3.5)), Petal.Length) # ascending Petal.Length
dplyr::arrange(filter(iris, between(Petal.Length, 3, 3.5)), desc(Petal.Length)) # descending Petal.Length
dplyr::arrange(filter(iris, between(Petal.Length, 3, 3.5)), Petal.Length, desc(Sepal.Length)) # ascending Petal.Length, descending Sepal.Length

# arrange using pipeline
result <- iris %>%
  filter(between(Petal.Length, 3, 3.5)) %>%
  arrange(Petal.Length)

# mutate
dplyr::mutate(iris, myvector=Sepal.Width^3) # data frame fusion

# summarize
dplyr::summarise(iris, varmean=mean(Sepal.Length)) # Sepal.Length's mean print

# group_by
summary_iris <- iris %>%
  group_by(Species) %>%
  summarise(
    Avg_Sepal_Length = mean(Sepal.Length),
    Avg_Sepal_Width = mean(Sepal.Width),
    Avg_Petal_Length = mean(Petal.Length),
    Avg_Petal_Width = mean(Petal.Width)
  )

dplyr::summarise(group_by(iris, Species), Avg_Sepal_Length = mean(Sepal.Length),
                 Avg_Sepal_Width = mean(Sepal.Width),
                 Avg_Petal_Length = mean(Petal.Length),
                 Avg_Petal_Width = mean(Petal.Width))

# join
df1 <- data.frame(
  ID = c(1, 2, 3, 4),
  Name = c("Alice", "Bob", "Charlie", "David")
)

df2 <- data.frame(
  ID = c(3, 4, 5, 6),
  Score = c(85, 90, 75, 88)
)

inner_result <- inner_join(df1, df2, by = "ID")
print(inner_result)

left_result <- left_join(df1, df2, by = "ID")
print(left_result)

right_result <- right_join(df1, df2, by = "ID")
print(right_result)

full_result <- full_join(df1, df2, by = "ID")
print(full_result)

### Chip DB, Provides annotation information for the microarray platform, 
# and this database package contains various biological information such as gene identifiers, gene names, and location of genes for probes present in the microarray chip
library(hgu95av2.db)
library(AnnotationDbi)
ls("package:hgu95av2.db")
View(hgu95av2_dbInfo())
columns(hgu95av2.db)
keytypes(hgu95av2.db)

head(keys(hgu95av2.db, keytype = "SYMBOL"))

# ⭐key를 기반으로 필요한 데이터 찾기
# Obtain information about a specific probe ID
probes <- head(keys(hgu95av2.db, keytype = "PROBEID"))

# keytype 매개변수는 keys에 제공된 값이 프로브 ID임을 명확하게 지정(권장됨)
info.v1 <- AnnotationDbi::select(hgu95av2.db, keys = probes, columns = c("GENENAME", "ENTREZID", "SYMBOL"), keytype = "PROBEID") 
info.v2 <- AnnotationDbi::mapIds(hgu95av2.db, keys = probes, column = c("GENENAME"), keytype = "PROBEID")

# Output the results
print(info.v1)
View(info.v2)

### Org DB, Contains annotation information for the Homosapiens (human) gene
library(org.Hs.eg.db)

# ⭐key를 기반으로 필요한 데이터 찾기
gene_ids <- AnnotationDbi::select(org.Hs.eg.db, 
                                  keys = c("BRCA1", "TP53"), 
                                  columns = c("ENTREZID", "GENENAME"), 
                                  keytype = "SYMBOL")
print(gene_ids)

uniKeys<-head(keys(org.Hs.eg.db, keytype = "UNIPROT"))
uniprot_code<-AnnotationDbi::select(org.Hs.eg.db,
                                    keys = uniKeys,
                                    columns = c("SYMBOL", "PATH"),
                                    keytype = "UNIPROT")
print(uniprot_code)

### Merge from DEG list
load(system.file("extdata", "resultTable.Rda", 
                 package="AnnotationDbi"))

annots <- AnnotationDbi::select(org.Hs.eg.db, 
                 keys=rownames(resultTable), # resultTable의 rownames를 key값으로 이용
                 columns=c("SYMBOL","GENENAME"), 
                 keytype="ENTREZID")

# 첫 번째 데이터프레임에서는 Row names가 두 번째 데이터프레임에서는 ENTREZID가 서로 조인속성임을 의미
# 두 데이터프레임의 조인속성 이름이 다르기 때문에 by.x, by.y로 지정해준것것
resultTable<-merge(resultTable, annots, by.x=0, by.y="ENTREZID") 
View(resultTable)

### GO DB, Gene Ontology 
library(GO.db)
keytypes(GO.db) # "DEFINITION" "GOID"       "ONTOLOGY"   "TERM"

GOIDs<-c("GO:0042254", "GO:0044183")
GOID_info<-AnnotationDbi::select(GO.db, keys=GOIDs, columns="DEFINITION", keytype="GOID")
GOID_info

### Tx DB, Including UCSC's 'knownGene' annotation based on human genome build HG19 (GRCh37)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb<-TxDb.Hsapiens.UCSC.hg19.knownGene

# 유전자 정보 조회
genes <- genes(txdb)

# 특정 유전자의 전사체 정보 조회
transcripts <- transcripts(txdb, filter = list(gene_id = "1234"))

keytypes(txdb)
keys<-head(keys(txdb, keytype = "GENEID"))
cols<-c("TXID", "TXSTART")
AnnotationDbi::select(txdb, keys=keys, columns=cols, keytype="GENEID")

### ⭐ggplot2
library(ggplot2)
# ggplot() 함수로 시작해서, aes() 함수로 aesthetic 매핑을 설정하고, 다양한 geom_ 함수로 그래프 유형을 추가하는 구조

## scatter plot
# basic
ggplot(data = mtcars, aes(x = hp, y = mpg)) +
  geom_point() +
  labs(title = "Scatter Plot of MPG vs Horsepower",
       x = "Horsepower",
       y = "Miles per Gallon") +
  theme(plot.title = element_text(hjust = 0.5)) # center align

# aesthetic 1: 점의 색상을 hp 값에 따라 다르게 설정
ggplot(data = mtcars, aes(x = hp, y = mpg)) +
  geom_point(aes(color=wt, hp, 30.1-0.068*hp)) + # weight add
  labs(title = "Scatter Plot of MPG vs Horsepower",
       x = "Horsepower",
       y = "Miles per Gallon") +
  theme(plot.title = element_text(hjust = 0.5)) # center align

# aesthetic 2: 점의 크기와 색상을 hp값에 따라 다르게 설정
ggplot(data = mtcars, aes(x = hp, y = mpg)) +
  geom_point(aes(color = hp, size = hp)) +  # 마력에 따라 색상과 크기 조정
  scale_color_gradient(low = "blue", high = "red") +  # 색상 그라디언트 설정
  labs(title = "Scatter Plot of MPG vs Horsepower",
       x = "Horsepower",
       y = "Miles per Gallon") +
  theme(plot.title = element_text(hjust = 0.5)) +  # 제목 중앙 정렬
  theme_minimal()  # 미니멀 테마 적용

# aesthetic 3: grid line과 axis text customizing
p7<-ggplot(data = mtcars, aes(x = hp, y = mpg)) +
  geom_point(aes(color = hp, size = hp)) +
  scale_color_gradient(low = "blue", high = "red") +
  labs(title = "Scatter Plot of MPG vs Horsepower",
       x = "Horsepower",
       y = "Miles per Gallon") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 20, face = "bold"),  # 제목 스타일
        axis.title.x = element_text(size = 14, face = "bold"),  # X축 제목 스타일
        axis.title.y = element_text(size = 14, face = "bold"),  # Y축 제목 스타일
        axis.text = element_text(color = "gray40"),  # 축 텍스트 색상
        panel.grid.major = element_line(color = "gray80"),  # 주 그리드 라인 색상
        panel.grid.minor = element_line(color = "gray90", linetype = "dotted"))  # 부 그리드 라인 스타일

# asethetic 4: legend 설정
ggplot(data = mtcars, aes(x = hp, y = mpg)) +
  geom_point(aes(color = hp, size = hp)) +
  scale_color_gradient(low = "blue", high = "red") +
  labs(title = "Scatter Plot of MPG vs Horsepower",
       x = "Horsepower",
       y = "Miles per Gallon") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        legend.position = "right") +  # 범례 위치 조정
  guides(color = guide_legend(title = "Horsepower"),  # 범례에 점의 크기와 색깔을 통합해서 표시시
         size = guide_legend(title = "Horsepower"))

## histogram
# aesthetic 1
ggplot(data = mtcars, aes(x = mpg)) +
  geom_histogram(bins = 10, fill = "blue", color = "black") +
  labs(title = "Histogram of MPG",
       x = "Miles per Gallon",
       y = "Frequency") +
  theme(plot.title = element_text(hjust = 0.5)) # center align

# aesthetic 2
ggplot(data = mtcars, aes(x = mpg)) +
  geom_histogram(bins = 10, fill = "#3498db", color = "#1f2d3d", alpha = 0.7) +  # Custom colors with transparency
  scale_x_continuous(breaks = seq(10, 35, by = 5)) +  # Custom x-axis breaks
  scale_y_continuous(labels = scales::comma) +  # Comma formatted y-axis labels
  labs(title = "Histogram of Miles per Gallon",
       subtitle = "From the mtcars Dataset",
       x = "Miles per Gallon",
       y = "Frequency",
       caption = "Source: Motor Trend Car Road Tests 1974") +
  theme_minimal() +  # Minimal theme
  theme(plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
        plot.subtitle = element_text(color = "grey60"),
        axis.title.x = element_text(size = 14, face = "bold"),
        axis.title.y = element_text(size = 14, face = "bold"),
        axis.text.x = element_text(angle = 45, hjust = 1),
        plot.caption = element_text(size = 8, hjust = 0, face = "italic"),
        legend.position = "none") +  # Customizing legend, text, and title positions
  geom_vline(aes(xintercept = mean(mpg, na.rm = TRUE)), color = "red", linetype = "dashed", size = 1) +  # Add mean line
  annotate("text", x = 25, y = 5, label = "Mean MPG", color = "red")  # Annotation near the mean line

## boxplot
# aesthetic 1: basic
ggplot(data = mtcars, aes(x = factor(cyl), y = mpg)) +
  geom_boxplot(fill = "tomato", color = "black") +
  labs(title = "Boxplot of MPG by Number of Cylinders",
       x = "Number of Cylinders",
       y = "Miles per Gallon") +
  theme(plot.title = element_text(hjust = 0.5)) # center align

# aesthetic 2: 
ggplot(data = mtcars, aes(x = factor(cyl), y = mpg)) +
  geom_boxplot(fill = "tomato", color = "black", outlier.colour = "blue", outlier.shape = 8, outlier.size = 3) +
  scale_y_continuous(breaks = seq(10, 35, by = 5)) +  # Custom y-axis breaks
  labs(title = "Boxplot of MPG by Number of Cylinders",
       subtitle = "Visualizing fuel efficiency variability among car models",
       x = "Number of Cylinders",
       y = "Miles per Gallon",
       caption = "Data from Motor Trend Car Road Tests 1974") +
  theme_bw() +  # Use the black and white theme for a clean layout
  theme(plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
        plot.subtitle = element_text(size = 12, margin = margin(b = 10)),
        plot.caption = element_text(size = 8, face = "italic"),
        axis.title.x = element_text(size = 14, face = "bold"),
        axis.title.y = element_text(size = 14, face = "bold"),
        axis.text.x = element_text(angle = 0, vjust = 0.5, color = "gray20"),
        axis.text.y = element_text(color = "gray20"),
        panel.grid.major = element_line(color = "gray80"),
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        legend.position = "none") +
  geom_jitter(width = 0.2, size = 2, color = "darkgray", alpha = 0.5)  # Add jitter to show data distribution

# aesthetic 3: facet_grid by ToothGrowth
ToothGrowth$dose<-as.factor(ToothGrowth$dose)

ggplot(data = ToothGrowth, aes(x = dose, y = len, group=dose))+
  geom_boxplot(aes(fill=dose))+
  # facet_grid(supp~.) # split in vertical direction
  # facet_grid(.~supp) # split in horizontal direction
  # facet_grid(dose~supp) # rows are dose and columns are supp
  # facet_grid(supp~dose) # rows are supp and columns are dose
  facet_wrap(~dose)

## barplot
mtc.sum<-dplyr::summarise(group_by(mtcars, gear), mpg=mean(mpg))

ggplot(mtc.sum, aes(x = factor(gear), y = mpg)) +  # Convert gear to factor for categorical plotting
  geom_bar(stat = "identity", fill = "steelblue", color = "black") +  # Use identity stat for pre-summarized data
  labs(title = "Average MPG by Gear",
       x = "Number of Gears",
       y = "Average Miles per Gallon") +
  scale_x_discrete(labels=c("Three","Four","Five"))+
  theme_minimal() +  # Using a minimal theme for a clean look
  theme(plot.title = element_text(hjust = 0.5))  # Center-align the title

# aesthetic 1
# Enhanced and beautified bar plot
ggplot(mtc.sum, aes(x = factor(gear), y = mpg)) + 
  geom_bar(stat = "identity", fill = "#3498db", color = "#2c3e50", width = 0.7) +  # Custom colors and bar width
  labs(title = "Average MPG by Gear",
       x = "Number of Gears",
       y = "Average Miles per Gallon") +
  scale_x_discrete(labels = c("Three", "Four", "Five")) +  # Custom labels for gear numbers
  theme_minimal(base_size = 14) +  # Using a minimal theme with adjusted base font size
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 16, color = "#34495e"),  # Bold and colored title
        plot.background = element_rect(fill = "#ecf0f1", color = NA),  # Light grey background for the plot area
        panel.background = element_rect(fill = "#ecf0f1"),  # Match plot background
        panel.grid.major = element_line(color = "#bdc3c7"),  # Lighter grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        axis.title = element_text(face = "bold", size = 14, color = "#2c3e50"),  # Bold and colored axis titles
        axis.text = element_text(color = "#2c3e50"),  # Colored axis text
        legend.position = "none")  # Hide legend if not needed

## lineplot
mtcars_sorted <- mtcars[order(mtcars$wt),]
ggplot(data = mtcars_sorted, aes(x = wt, y = mpg)) +
  geom_line() +
  labs(title = "Line Graph of MPG by Weight",
       x = "Weight (1000 lbs)",
       y = "Miles per Gallon") +
  theme(plot.title = element_text(hjust = 0.5)) # center align

### plotly, Gviz, GenomicRanges
## plotly
library(plotly)
ggplotly(p7) # mouse pointer

## Gviz and GenomicRanges
library(Gviz)
library(GenomicRanges)
data("cpgIslands")
chr<-as.character(unique(seqnames(cpgIslands)))
gen<-genome(cpgIslands)
atrack<-AnnotationTrack(cpgIslands, name="CpG")
plotTracks(atrack)

# GenomeAxisTrack: genome plot
gtrack<-GenomeAxisTrack()
plotTracks(list(gtrack,atrack))

# IdeogramTrack: 
itrack<-IdeogramTrack(genome=gen, chromosome = chr)
plotTracks(list(itrack, gtrack, atrack))

# Gene Region Track
data("geneModels")
grtrack<-GeneRegionTrack(geneModels, genome = gen,
                         chromosome = chr, name = "Gene Model")
plotTracks(list(itrack, gtrack, atrack, grtrack))

plotTracks(list(itrack, gtrack, atrack, grtrack), from=26700000, to=26750000)

# Track plot 꾸미기
grtrack <- GeneRegionTrack(geneModels, genome = gen, 
                           chromosome = chr, 
                           name = "Gene Model",
                           transcriptAnnotation = "symbol",
                           background.title = "brown")
displayPars(grtrack) <- list(background.panel = "#FFFEDB", col = NULL)
plotTracks(list(itrack, gtrack, atrack, grtrack))
plotTracks(list(itrack, gtrack, atrack, grtrack), 
            background.panel = "#FFFEDB", background.title = "darkblue")

# ☢️Available Display Pars
dp <- availableDisplayPars(grtrack)
tail(dp)

# Reverse Strand
plotTracks(list(itrack, gtrack, atrack, grtrack), reverseStrand = TRUE)

# ☢️Genome Axis Track
axisTrack <- GenomeAxisTrack()
plotTracks(axisTrack, from = 1e6, to = 9e6)
axisTrack <- GenomeAxisTrack(range=IRanges(start = c(2e6, 4e6), end = c(3e6, 7e6), names = rep("N-stretch", 2)))
plotTracks(axisTrack, from = 1e6, to = 9e6)
plotTracks(axisTrack, from = 1e6, to = 9e6, showId = TRUE)
plotTracks(axisTrack, from = 1e6, to = 9e6, add53 = TRUE, add35 = TRUE)
plotTracks(axisTrack, from = 1e6, to = 9e6, add53 = TRUE, add35 = TRUE, littleTicks = TRUE)

# ☢️AnnotationTrack
aTrack <- AnnotationTrack(start = c(10, 40, 120), width = 15, 
                          chromosome = "chrX", 
                          strand = c("+", "*", "-"),
                          id = c("Huey", "Dewey", "Louie"), 
                          genome = "hg19", name = "foo")
plotTracks(aTrack)
plotTracks(aTrack, shape = "box", featureAnnotation = "id")
plotTracks(aTrack, shape = "ellipse", featureAnnotation = "id", 
          fontcolor.feature = "darkblue")

# Sequence Track
library(BSgenome.Hsapiens.UCSC.hg19)
strack <- SequenceTrack(Hsapiens, chromosome = chr)
plotTracks(list(itrack, gtrack, atrack, grtrack, strack), 
           from = 26591822, to = 26591852, cex = 0.8)

# Data Point Track
set.seed(255)
lim <- c(26700000, 26750000)
coords <- sort(c(lim[1], 
                   sample(seq(from = lim[1], to = lim[2]), 99), 
                   lim[2]))
dat <- runif(100, min = -10, max = 10)
dtrack <- DataTrack(data = dat, start = coords[-length(coords)],
                        end = coords[-1], chromosome = chr, genome = gen, name = "Uniform")
plotTracks(list(itrack, gtrack, atrack, grtrack, dtrack), 
             from = lim[1], to = lim[2])

plotTracks(list(itrack, gtrack, atrack, grtrack, dtrack), 
           from = lim[1], to = lim[2], type = "histogram")
